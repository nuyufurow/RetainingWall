using LinearAlgebra;
using LinearAlgebra.VectorAlgebra;

namespace Dr.RetainingWall.Core
{
    class InnerForceCalculation
    {
        public static Vector neilijisuan01(Matrix K, Matrix k, Vector f, int n, Matrix Q, Matrix H)
        {
            //本子函数用于求解节点位移和结构内力以及支座反力,适用于墙底固结
            //输入的k为总刚度矩阵（为引入位移边界条件划掉0行0列），f为等效节点荷载列向量（为引入位移边界条件划掉0行0列）,n为挡土墙层数
            //Q = hezaijisuan(n, H, r, h, p0, rg, rq);    //调用荷载计算子程序，计算所有节点的荷载设计值
            Vector u = Vector.MatMulColVec(k.Inverse(), f);       //左除总刚度矩阵，求解未知位移
            VectorUtil.Vpa(ref u, 7);                             //将求解的位移保留7位有效数字
            if (n == 1)
            {
                Vector U = new Vector(new double[] { 0, 0, 0, u[1], 0, u[2] }, VectorType.Column);             //回带总体位移
                Vector F = Vector.MatMulColVec(K, U);            //求支反力，此支反力为未加上全部加上刚臂时，只有节点荷载的支反力
                                                                 //支反力修正为真正结构的支反力，令F + 结构全部加上刚臂时的节点反力，得到真正结构的内力和支反力
                double Fa = (Q[1, 1] - Q[1, 2]) * H[1, 1] * 7 / 20 + 0.5 * Q[1, 2] * H[1, 1];                  //A点等效节点剪力
                double Ma = (Q[1, 1] - Q[1, 2]) * H[1, 1] * H[1, 1] / 20 + Q[1, 2] * H[1, 1] * H[1, 1] / 12;   //A点等效节点弯矩
                double Fb = (Q[1, 1] - Q[1, 2]) * H[1, 1] * 3 / 20 + 0.5 * Q[1, 2] * H[1, 1];                  //B点等效节点剪力
                double Mb = -((Q[1, 1] - Q[1, 2]) * H[1, 1] * H[1, 1] / 30 + Q[1, 2] * H[1, 1] * H[1, 1] / 12);//B点等效节点弯矩
                F = F + new Vector(new double[] { 0, Fa, Ma, 0, Fb, Mb }, VectorType.Column);                  //支反力修正为真正结构的支反力
                return F;                                                                                      //输出所有节点的内力

            }
            else if (n == 2)
            {
                Vector U = new Vector(new double[] { 0, 0, 0, u[1], 0, u[2], u[3], 0, u[4] }, VectorType.Column);  //回带总体位移
                Vector F = Vector.MatMulColVec(K, U);            //求支反力，此支反力为未加上全部加上刚臂时，只有节点荷载的支反力
                                                                 //支反力修正为真正结构的支反力，令F + 结构全部加上刚臂时的节点反力，得到真正结构的内力和支反力
                double Ma = (Q[1, 1] - Q[1, 2]) * H[1, 1] * H[1, 1] / 20 + Q[1, 2] * H[1, 1] * H[1, 1] / 12;       //A点等效节点弯矩
                double Fa = (Q[1, 1] - Q[1, 2]) * H[1, 1] * 7 / 20 + 0.5 * Q[1, 2] * H[1, 1];                      //A点等效节点剪力
                double Mb = -(((Q[1, 1] - Q[1, 2]) * H[1, 1] * H[1, 1] / 30 + Q[1, 2] * H[1, 1] * H[1, 1] / 12)
                    - ((Q[1, 2] - Q[1, 3]) * H[1, 2] * H[1, 2] / 20 + Q[1, 3] * H[1, 2] * H[1, 2] / 12));          //B点等效节点弯矩
                double Fb = (Q[1, 1] - Q[1, 2]) * H[1, 1] * 3 / 20 + 0.5 * Q[1, 2] * H[1, 1] + (Q[1, 2] - Q[1, 3])
                    * H[1, 2] * 7 / 20 + 0.5 * Q[1, 3] * H[1, 2];                                                  //B点等效节点剪力
                double Mc = -((Q[1, 2] - Q[1, 3]) * H[1, 2] * H[1, 2] / 30 + Q[1, 3] * H[1, 2] * H[1, 2] / 12);    //C点等效节点弯矩
                double Fc = (Q[1, 2] - Q[1, 3]) * H[1, 2] * 3 / 20 + 0.5 * Q[1, 3] * H[1, 2];                      //C点等效节点剪力
                F = F + new Vector(new double[] { 0, Fa, Ma, 0, Fb, Mb, 0, Fc, Mc }, VectorType.Column);           //支反力修正为真正结构的支反力
                return F;                                                                                          //输出所有节点的内力
            }
            else if (n == 3)
            {
                Vector U = new Vector(new double[] { 0, 0, 0, u[1], 0, u[2], u[3], 0, u[4], u[5], 0, u[6] }, VectorType.Column);  //回带总体位移
                Vector F = Vector.MatMulColVec(K, U);            //求支反力，此支反力为未加上全部加上刚臂时，只有节点荷载的支反力
                                                                 //支反力修正为真正结构的支反力，令F + 结构全部加上刚臂时的节点反力，得到真正结构的内力和支反力
                double Ma = (Q[1, 1] - Q[1, 2]) * H[1, 1] * H[1, 1] / 20 + Q[1, 2] * H[1, 1] * H[1, 1] / 12;                    //A点等效节点弯矩
                double Fa = (Q[1, 1] - Q[1, 2]) * H[1, 1] * 7 / 20 + 0.5 * Q[1, 2] * H[1, 1];                                   //A点等效节点剪力
                double Mb = -(((Q[1, 1] - Q[1, 2]) * H[1, 1] * H[1, 1] / 30 + Q[1, 2] * H[1, 1] * H[1, 1] / 12)
                    - ((Q[1, 2] - Q[1, 3]) * H[1, 2] * H[1, 2] / 20 + Q[1, 3] * H[1, 2] * H[1, 2] / 12));                       //B点等效节点弯矩
                double Fb = (Q[1, 1] - Q[1, 2]) * H[1, 1] * 3 / 20 + 0.5 * Q[1, 2] * H[1, 1] + (Q[1, 2] - Q[1, 3])
                    * H[1, 2] * 7 / 20 + 0.5 * Q[1, 3] * H[1, 2];                                                               //B点等效节点剪力
                double Mc = -(((Q[1, 2] - Q[1, 3]) * H[1, 2] * H[1, 2] / 30 + Q[1, 3] * H[1, 2] * H[1, 2] / 12)
                    - ((Q[1, 3] - Q[1, 4]) * H[1, 3] * H[1, 3] / 20 + Q[1, 4] * H[1, 3] * H[1, 3] / 12));                       //C点等效节点弯矩
                double Fc = (Q[1, 2] - Q[1, 3]) * H[1, 2] * 3 / 20 + 0.5 * Q[1, 3] * H[1, 2]
                    + (Q[1, 3] - Q[1, 4]) * H[1, 3] * 7 / 20 + 0.5 * Q[1, 4] * H[1, 3];                                         //C点等效节点剪力
                double Md = -((Q[1, 3] - Q[1, 4]) * H[1, 3] * H[1, 3] / 30 + Q[1, 4] * H[1, 3] * H[1, 3] / 12);                 //D点等效节点弯矩
                double Fd = (Q[1, 3] - Q[1, 4]) * H[1, 3] * 3 / 20 + 0.5 * Q[1, 4] * H[1, 3];                                   //D点等效节点剪力
                F = F + new Vector(new double[] { 0, Fa, Ma, 0, Fb, Mb, 0, Fc, Mc, 0, Fd, Md }, VectorType.Column);             //支反力修正为真正结构的支反力
                return F;                                                                                                       //输出所有节点的内力
            }
            else if (n == 4)
            {
                Vector U = new Vector(new double[] { 0, 0, 0, u[1], 0, u[2], u[3], 0, u[4], u[5], 0, u[6], u[7], 0, u[8]},VectorType.Column ); //回带总体位移
                Vector F = Vector.MatMulColVec(K, U);           //求支反力，此支反力为未加上全部加上刚臂时，只有节点荷载的支反力
                                                                //支反力修正为真正结构的支反力，令F + 结构全部加上刚臂时的节点反力，得到真正结构的内力和支反力
                double Ma = (Q[1, 1] - Q[1, 2]) * H[1, 1] * H[1, 1] / 20 + Q[1, 2] * H[1, 1] * H[1, 1] / 12;                   //A点等效节点弯矩
                double Fa = (Q[1, 1] - Q[1, 2]) * H[1, 1] * 7 / 20 + 0.5 * Q[1, 2] * H[1, 1];                                  //A点等效节点剪力
                double Mb = -(((Q[1, 1] - Q[1, 2]) * H[1, 1] * H[1, 1] / 30 + Q[1, 2] * H[1, 1] * H[1, 1] / 12)                
                    - ((Q[1, 2] - Q[1, 3]) * H[1, 2] * H[1, 2] / 20 + Q[1, 3] * H[1, 2] * H[1, 2] / 12));                      //B点等效节点弯矩
                double Fb = (Q[1, 1] - Q[1, 2]) * H[1, 1] * 3 / 20 + 0.5 * Q[1, 2] * H[1, 1] + (Q[1, 2] - Q[1, 3])             
                    * H[1, 2] * 7 / 20 + 0.5 * Q[1, 3] * H[1, 2];                                                              //B点等效节点剪力
                double Mc = -(((Q[1, 2] - Q[1, 3]) * H[1, 2] * H[1, 2] / 30 + Q[1, 3] * H[1, 2] * H[1, 2] / 12)                
                    - ((Q[1, 3] - Q[1, 4]) * H[1, 3] * H[1, 3] / 20 + Q[1, 4] * H[1, 3] * H[1, 3] / 12));                      //C点等效节点弯矩
                double Fc = (Q[1, 2] - Q[1, 3]) * H[1, 2] * 3 / 20 + 0.5 * Q[1, 3] * H[1, 2] + (Q[1, 3] - Q[1, 4])             
                    * H[1, 3] * 7 / 20 + 0.5 * Q[1, 4] * H[1, 3];                                                              //C点等效节点剪力
                double Md = -(((Q[1, 3] - Q[1, 4]) * H[1, 3] * H[1, 3] / 30 + Q[1, 4] * H[1, 3] * H[1, 3] / 12)                
                    - ((Q[1, 4] - Q[1, 5]) * H[1, 4] * H[1, 4] / 20 + Q[1, 5] * H[1, 4] * H[1, 4] / 12));                      //D点等效节点弯矩
                double Fd = (Q[1, 3] - Q[1, 4]) * H[1, 3] * 3 / 20 + 0.5 * Q[1, 4] * H[1, 3] + (Q[1, 4] - Q[1, 5])             
                    * H[1, 4] * 7 / 20 + 0.5 * Q[1, 5] * H[1, 4];                                                              //D点等效节点剪力
                double Me = -((Q[1, 4] - Q[1, 5]) * H[1, 4] * H[1, 4] / 30 + Q[1, 5] * H[1, 4] * H[1, 4] / 12);                //E点等效节点弯矩
                double Fe = (Q[1, 4] - Q[1, 5]) * H[1, 4] * 3 / 20 + 0.5 * Q[1, 5] * H[1, 4];                                  //E点等效节点剪力
                F = F + new Vector(new double[] { 0, Fa, Ma, 0, Fb, Mb, 0, Fc, Mc, 0, Fd, Md, 0, Fe, Me}, VectorType.Column);  //支反力修正为真正结构的支反力
                return F;                                                                                                      //输出所有节点的内力
            }
            return new Vector(new double[] { 0 }, VectorType.Column);
        }

    }
}
